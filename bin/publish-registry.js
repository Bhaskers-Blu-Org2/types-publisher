"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const fs_extra_1 = require("fs-extra");
const yargs = require("yargs");
const get_definitely_typed_1 = require("./get-definitely-typed");
const common_1 = require("./lib/common");
const npm_client_1 = require("./lib/npm-client");
const packages_1 = require("./lib/packages");
const settings_1 = require("./lib/settings");
const versions_1 = require("./lib/versions");
const io_1 = require("./util/io");
const logging_1 = require("./util/logging");
const util_1 = require("./util/util");
const packageName = "types-registry";
const registryOutputPath = util_1.joinPaths(settings_1.outputDirPath, packageName);
const readme = `This package contains a listing of all packages published to the @types scope on NPM.
Generated by [types-publisher](https://github.com/Microsoft/types-publisher).`;
if (!module.parent) {
    const dry = !!yargs.argv.dry;
    util_1.logUncaughtErrors(async () => {
        const dt = await get_definitely_typed_1.getDefinitelyTyped(common_1.Options.defaults);
        await publishRegistry(dt, await packages_1.AllPackages.read(dt), dry, new npm_client_1.UncachedNpmInfoClient());
    });
}
async function publishRegistry(dt, allPackages, dry, client) {
    const [log, logResult] = logging_1.logger();
    log("=== Publishing types-registry ===");
    const { version: oldVersion, highestSemverVersion, contentHash: oldContentHash, lastModified } = await versions_1.fetchAndProcessNpmInfo(packageName, client);
    // Don't include not-needed packages in the registry.
    const registryJsonData = await npm_client_1.CachedNpmInfoClient.with(client, cachedClient => generateRegistry(allPackages.allLatestTypings(), cachedClient));
    const registry = JSON.stringify(registryJsonData);
    const newContentHash = util_1.computeHash(registry);
    assert.strictEqual(oldVersion.major, 0);
    assert.strictEqual(oldVersion.minor, 1);
    const newVersion = `0.1.${oldVersion.patch + 1}`;
    const packageJson = generatePackageJson(newVersion, newContentHash);
    await generate(registry, packageJson);
    const publishClient = () => npm_client_1.NpmPublishClient.create({ defaultTag: "next" });
    if (!highestSemverVersion.equals(oldVersion)) {
        // There was an error in the last publish and types-registry wasn't validated.
        // This may have just been due to a timeout, so test if types-registry@next is a subset of the one we're about to publish.
        // If so, we should just update it to "latest" now.
        log("Old version of types-registry was never tagged latest, so updating");
        await validateIsSubset(await packages_1.readNotNeededPackages(dt));
        await (await publishClient()).tag(packageName, highestSemverVersion.versionString, "latest");
    }
    else if (oldContentHash !== newContentHash && isAWeekAfter(lastModified)) {
        log("New packages have been added, so publishing a new registry.");
        await publish(await publishClient(), packageJson, newVersion, dry, log);
    }
    else {
        const reason = oldContentHash === newContentHash ? "Was modified less than a week ago" : "No new packages published";
        log(`${reason}, so no need to publish new registry.`);
        // Just making sure...
        await validate();
    }
    await logging_1.writeLog("publish-registry.md", logResult());
}
exports.default = publishRegistry;
const millisecondsPerDay = 1000 * 60 * 60 * 24;
function isAWeekAfter(time) {
    const diff = Date.now() - time.getTime();
    const days = diff / millisecondsPerDay;
    return days > 7;
}
async function generate(registry, packageJson) {
    await fs_extra_1.emptyDir(registryOutputPath);
    await writeOutputJson("package.json", packageJson);
    await writeOutputFile("index.json", registry);
    await writeOutputFile("README.md", readme);
    function writeOutputJson(filename, content) {
        return io_1.writeJson(outputPath(filename), content);
    }
    function writeOutputFile(filename, content) {
        return io_1.writeFile(outputPath(filename), content);
    }
    function outputPath(filename) {
        return util_1.joinPaths(registryOutputPath, filename);
    }
}
async function publish(client, packageJson, version, dry, log) {
    await client.publish(registryOutputPath, packageJson, dry, log);
    // Sleep for 60 seconds to let NPM update.
    await io_1.sleep(60);
    // Don't set it as "latest" until *after* it's been validated.
    await validate();
    await client.tag(packageName, version, "latest");
}
async function installForValidate() {
    await fs_extra_1.emptyDir(settings_1.validateOutputPath);
    await io_1.writeJson(util_1.joinPaths(settings_1.validateOutputPath, "package.json"), {
        name: "validate",
        version: "0.0.0",
        description: "description",
        readme: "",
        license: "",
        repository: {},
    });
    const npmPath = util_1.joinPaths(__dirname, "..", "node_modules", "npm", "bin", "npm-cli.js");
    const err = (await util_1.execAndThrowErrors(`node ${npmPath} install types-registry@next ${io_1.npmInstallFlags}`, settings_1.validateOutputPath)).trim();
    if (err) {
        console.error(err);
    }
}
const validateTypesRegistryPath = util_1.joinPaths(settings_1.validateOutputPath, "node_modules", "types-registry");
async function validate() {
    await installForValidate();
    assertJsonNewer(await io_1.readJson(util_1.joinPaths(registryOutputPath, "index.json")), await io_1.readJson(util_1.joinPaths(validateTypesRegistryPath, "index.json")));
}
async function validateIsSubset(notNeeded) {
    await installForValidate();
    const indexJson = "index.json";
    const actual = await io_1.readJson(util_1.joinPaths(validateTypesRegistryPath, indexJson));
    const expected = await io_1.readJson(util_1.joinPaths(registryOutputPath, indexJson));
    for (const key in actual.entries) {
        if (!(key in expected.entries) && !notNeeded.some(p => p.name === key)) {
            throw new Error(`Actual types-registry has unexpected key ${key}`);
        }
    }
}
function assertJsonNewer(newer, older, parent = "") {
    for (const key of Object.keys(older)) {
        assert(newer.hasOwnProperty(key), `${key} in ${parent} was not found in newer`);
        switch (typeof newer[key]) {
            case "string":
                const newerver = versions_1.Semver.tryParse(newer[key]);
                const olderver = versions_1.Semver.tryParse(older[key]);
                const condition = newerver && olderver ?
                    newerver.greaterThan(olderver) || newerver.equals(olderver) :
                    newer[key] >= older[key];
                assert(condition, `${key} in ${parent} did not match: newer[key] (${newer[key]}) < older[key] (${older[key]})`);
                break;
            case "number":
                assert(newer[key] >= older[key], `${key} in ${parent} did not match: newer[key] (${newer[key]}) < older[key] (${older[key]})`);
                break;
            case "boolean":
                assert(newer[key] === older[key], `${key} in ${parent} did not match: newer[key] (${newer[key]}) !== older[key] (${older[key]})`);
                break;
            default:
                assertJsonNewer(newer[key], older[key], key);
        }
    }
}
function generatePackageJson(version, typesPublisherContentHash) {
    return {
        name: packageName,
        version,
        description: "A registry of TypeScript declaration file packages published within the @types scope.",
        repository: {
            type: "git",
            url: "https://github.com/Microsoft/types-publisher.git",
        },
        keywords: [
            "TypeScript",
            "declaration",
            "files",
            "types",
            "packages",
        ],
        author: "Microsoft Corp.",
        license: "MIT",
        typesPublisherContentHash,
    };
}
async function generateRegistry(typings, client) {
    const entries = {};
    for (const typing of typings) {
        // Unconditionally use cached info, this should have been set in calculate-versions so should be recent enough.
        const info = client.getNpmInfoFromCache(typing.fullEscapedNpmName);
        if (!info) {
            const missings = typings.filter(t => !client.getNpmInfoFromCache(t.fullEscapedNpmName)).map(t => t.fullEscapedNpmName);
            throw new Error(`${missings} not found in ${client.formatKeys()}`);
        }
        entries[typing.name] = filterTags(info.distTags);
    }
    return { entries };
    function filterTags(tags) {
        const latestTag = "latest";
        const latestVersion = tags.get(latestTag);
        const out = {};
        tags.forEach((value, tag) => {
            if (tag === latestTag || value !== latestVersion) {
                out[tag] = value;
            }
        });
        return out;
    }
}
//# sourceMappingURL=publish-registry.js.map